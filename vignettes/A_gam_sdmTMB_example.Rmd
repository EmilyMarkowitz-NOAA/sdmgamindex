---
title: "Fitting a spatiotemporal model and deriving an abundance index"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A_gam_sdmTMB_example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, message=FALSE, error=FALSE, warning = FALSE, 
  comment = "#>", 
  eval = FALSE
)
```

<!-- --- -->
<!-- title: "Fitting a spatiotemporal model and deriving an abundance index" -->
<!-- format: html -->
<!-- editor: visual -->
<!-- execute:  -->
<!--   echo: true -->
<!--   eval: true -->
<!-- --- -->

> Adapted from Lewis Barnett's sdmTMB tutorial for the Fisheries Survey Course at UW: [GitHub pbs-assess/sdmTMB-teaching 2023-02-14](https://github.com/pbs-assess/sdmTMB-teaching/blob/490ee04157f19d1059c55a1318b894e8b8f460bb/uw-survey-2023/02-exercise.qmd#L356)

# Goals of the original exercise:

-   Practice fitting a basic spatiotemporal model.
-   Understand how to inspect the model output.
-   Practice predicting from the model on new data and making visualizations of those predictions.
-   Gain familiarity with fitting, comparing and interpreting different random field structures.
-   Calculate an area-weighted biomass index and compare how model structure can impact an index.

# Our goals for this vignette:

- Fit a GAM and obtain an area-weighted biomass index
- Fit a basic spatiotemporal model (a GLMM!) using sdmTMB and compare GAM to GLMM 

```{r install_inla, eval = FALSE, include = FALSE}
# install.packages("INLA", repos = c(getOption("repos"), INLA = "https://inla.r-inla-download.org/R/stable"), dependencies = TRUE)
#library(remotes)
#remotes::install_github("pbs-assess/sdmTMB", dependencies = TRUE)
```

```{r}
PKG <- c(
  "sdmTMB", # install.packages("sdmTMB", dependencies = TRUE)
  "mgcv", 
  "gratia",
  "visreg", 
  "gstat",
  "dplyr", 
  "ggplot2", 
  "INLA",
  "prediction",
  "inlabru", 
  "purrr")

for (p in PKG) {
  if(!require(p,character.only = TRUE)) {  
    install.packages(p)
    require(p,character.only = TRUE)}
}

options(ggplot2.continuous.colour = "viridis")
options(ggplot2.continuous.fill = "viridis")
theme_set(theme_light())
```

Check your system:

```{r}
sessionInfo()
```

# The data

We will work with data representing North Pacific Spiny Dogfish in the West Coast Vancouver Island synoptic trawl survey.

```{r, include = FALSE}
# https://drive.google.com/drive/folders/14h9nrWR_eoSlmfFI0KXfotEIJHyVJzHQ
dat <- readRDS(here::here("notforgit/uw-survey-2023/data/wcvi-dogfish.rds"))
head(dat)

dat <- readRDS(here::here("data/ebs_yfs_example.RDS"))

#load(here::here("data/noaa_afsc_public_foss.rda"))
#yfs <- noaa_afsc_public_foss %>% filter(srvy=="EBS" & species_code == 10210 )
#saveRDS(object = yfs,file = here::here("data/ebs_yfs_example.RDS"))
```

The dataset contains sampling locations (`longitude` and `latitude`) and `year`. It also contains sampling `depth` in meters and sample CPUE `density` in units of tonnes/km^2^.

```{r}
ggplot(data = dat, 
       mapping = aes(x = longitude_dd, y = latitude_dd, size = cpue_kgkm2,color = bottom_temperature_c)) + 
  geom_point(alpha = 0.3)
```



# Fit a GAM to spatial data (analogous to spatial-only model in sdmTMB)

## Add UTM columns
```{r}
dat <- add_utm_columns(dat, 
                       utm_crs = 3156, 
                       ll_names = c("longitude", "latitude"))
ggplot(dat, aes(X, Y, size = density)) + 
  geom_point(shape = 21) + 
  coord_fixed()
```


Include a 2-D smooth over space. 

```{r}
fit_gam_s <- gam(
  formula = density ~ s(depth) + as.factor(year) + 
    s(X,Y), #<<
  family = tw(link = "log"),
  data = dat
)
```


# Other ways to visualize smooths

Visualize smooths, where the first plot shows the 1-D smooth on depth and 
the second plot shows the 2-D (or bivariate) spatial smooth

```{r}
plot(fit_gam_s)
```

or

```{r}
plot(fit_gam_s, scheme = 1)
```

or

```{r}
plot(fit_gam_s, scheme = 2)
```


# Fit a GAM analogous to a spatiotemporal model in sdmTMB

Include a 2-D smooth over space for each year

```{r}
fit_gam_st <- gam(
  formula = density ~ s(depth) + as.factor(year) +
    s(X,Y, by = year), 
  family = tw(link = "log"),
  data = dat)


```


We will create these new columns to use later:

```{r}
dat$log_depth <- log(dat$depth)
dat$year_factor <- as.factor(dat$year)
```


# Index standardization

To calculate an index from any of these models, we need to run the `predict.sdmTMB()` function with the argument `return_tmb_object = TRUE`. We can then run the `get_index()` function to extract the total biomass calculations and standard errors.

We can set the area argument to our `cell_area` column in km^2^. In this case the value is 4 km^2^ for all of the cells, since our grid cells are 2 km x 2 km. If some grid cells were not fully in the survey domain (or were on land), we could feed a vector of grid areas to the area argument that matched the number of grid cells. Because the density units are tonnes per km^2^ for this data, the index is in tonnes.

```{r}
p <- predict(fit, newdata = grid, return_tmb_object = TRUE)
index <- get_index(p, area = grid$cell_area, bias_correct = FALSE)

ggplot(index, aes(year, est)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab("Year") +
  ylab("Biomass estimate (tonnes)")
```

We used `bias_correction = FALSE` to speed things up, but for any final result you will want to use the bias correction. Let's see how much the scale of the index changes with bias correction.

```{r}
index_c <- get_index(p, area = grid$cell_area, bias_correct = TRUE)
index_c$Method <- "Bias correction"

bind_rows(index, index_c) %>%
  ggplot(aes(year, est, fill = Method)) +
  geom_line(aes(colour = Method)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab("Year") +
  ylab("Biomass estimate (tonnes)")
```

# Fit a few GAMs and estimate an abundance index

Include a covariate (depth)

Analogous to nonspatial model (spatial = "off", spatiotemporal = "off")

```{r}
fit_gam <- gam(
  formula = density ~ s(depth) + as.factor(year),
  family = tw(link = "log"),
  data = dat
)
```

Get model summary

```{r}
summary(fit_gam)
```

Plot partial effects of covariates

```{r}
plot(fit_gam, shade = TRUE, residuals = TRUE)
```

Get diagnostics and perform model checking

```{r}
gam.check(fit_gam)
```

Review console output to help verify convergence, and whether there were an adequate number of basis functions (k).

Examine the four diagnostic plots. Each of these gives a different way of looking at your model residuals. On the top-left is a Q-Q plot, which compares the model residuals to the expected/assumed distribution family. A well-fit model's residuals will be close to the 1-1 line, otherwise there may be under- or over-dispersion present. On bottom left is a histogram of residuals. We want this to have a shape similar to the distribution family we specified. On top-right is a plot of residual values as a function of the linear predictor. These should be evenly distributed around zero in a well-fitted model. Finally, on the bottom-right is plot of response against fitted values. A well-fitted model would show values near the 1-1 line.

# Predict to survey area (new data)

```{r}
pred_gam <- predict(fit_gam, type = "response", newdata = grid)
pred_gam_df <- cbind(grid, pred_gam)
```

Plot predictions over survey area

```{r}
ggplot(pred_gam_df, aes(X, Y, fill = pred_gam)) + geom_raster() +
  scale_fill_viridis_c() + facet_wrap(~year) + coord_fixed() +
  labs(fill = "Log Biomass density\n(kg/km^2)")
```

# Calculate biomass index from GAM via simulation

```{r}
sims <- gratia::fitted_samples(fit_gam, n=10, newdata=grid, 
                               scale="response", seed=9)
sims$year <- grid$year[sims$row]
sims$biomass <- sims$fitted * 4 # expand from density to biomass, given area

level <- 0.95 # specify probability for confidence interval

# Get sum of simulated biomass (density*area) across grid cells, with CI
lwr_fn <- function(x) {as.numeric(quantile(x, probs = (1 - level) / 2))}
upr_fn <- function(x) {as.numeric(quantile(x, probs = 1 - (1 - level) / 2))}

sims_sum <-  sims %>% 
  group_by(year,draw) %>% 
  summarise_at("biomass", list(biomass = sum)) %>%
  group_by(year) %>%
  summarise_at("biomass", list(est = median, # could use mean
                           lwr = lwr_fn,
                           upr = upr_fn))
```

Note that this approach uses a Gaussian approximation to the posterior, which is all that is implemented currently in the gratia package. However, a better estimate of uncertainty could be derived from sampling from the actual posterior distribution. However, this is beyond the scope of today's lesson.

Plot the biomass index

```{r}
ggplot(sims_sum, aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab('Year') + ylab('Biomass estimate (kg)')
```
